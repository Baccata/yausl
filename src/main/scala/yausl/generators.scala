/*
 * Copyright 2015 Olivier MÃ©lois
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yausl

import shapeless.HList.ListCompat._
import shapeless.LUBConstraint.<<:
import shapeless.{CaseClassMacros, LUBConstraint, HList}

import scala.annotation.StaticAnnotation
import scala.language.experimental.macros
import scala.reflect.macros.whitebox
import scala.reflect.macros.whitebox.Context

object SystemGenerator {


  /**
   *  A helper method that reads code from the "body" and uses it at macro expansion.
   *  In our case it circumvents the reflective calls usually made by macro-generated types
   *  (which are structural types). Not only does this reduces the performance loss due to
   *  reflection, but creating instances of value classes cannot be performed by reflective
   *  calls, because these instances are not boxes (the values are not boxed).
   *
   *  This trick is called "vampire methods".
    */
  def method_impl[Units <: HList, Dims <: HList](c: whitebox.Context) : c.Expr[yausl.Scalar[Units, Dims]] = {
    import c.universe._
    import org.scalamacros.resetallattrs._

    val prefixVal = TermName(c.freshName())
    val prefixVal2 = TermName(c.freshName())

    object replaceThises extends Transformer {
      override def transform(tree: Tree) = tree match {
        case This(qual) if qual.decodedName.toString.startsWith("System") => Ident(prefixVal)
        case This(qual) if qual.decodedName.toString.startsWith("unitExtension") => Ident(prefixVal2)
        case other => super.transform(other)
      }
    }

    val body = c.macroApplication.symbol.annotations.find(
      _.tree.tpe <:< typeOf[body]
    ).flatMap { x =>
      x.tree.children.tail.collectFirst {
        case body : Tree => c.resetAllAttrs(body)
      }
    }.getOrElse(c.abort(c.enclosingPosition, "Annotation body not provided!"))

    c.Expr(
      q"""
        val $prefixVal = ${c.prefix}
        val $prefixVal2 = ${c.prefix}
        ${replaceThises.transform(body)}
        """
    )
  }

  def fromHList[Units <: HList](implicit ev: LUBConstraint[Units, UnitM[_]]): System[Units] =
  macro SystemMacros.fromHListImpl[Units]

  class SystemMacros(val c: whitebox.Context) extends CaseClassMacros {

    /**
     * This macro definition generates a type that is not vampired. Therefore, its use will
     * trigger a warning at compile time.
     */
    def fromHListImpl[Units <: HList : c.WeakTypeTag](ev: c.Expr[LUBConstraint[Units, UnitM[_]]]) = {
      import c.universe._
      val tpe = c.weakTypeOf[Units]
      val integer_1 = c.weakTypeOf[p1]
      val integer_0 = c.weakTypeOf[_0]
      val units = hlistElements(tpe)

      def dimsOf(t : Type) = mkHListTpe(units map {u => if (u == t) integer_1 else integer_0})

      val className = TypeName(c.freshName("System"))
      val extensionName = TypeName(c.freshName("unitExtension"))

      c.Expr[System[Units]](

        q"""
          class $className extends yausl.System[$tpe] {

            implicit class $extensionName(val value : Double){
              ..${ units.map { t =>
                    val name = t.typeSymbol.name.toString
                    val dims = dimsOf(t)
                    q"""
                      @yausl.body(yausl.System.scalar[$tpe, $dims](value))
                      def ${TermName(name)} : yausl.Scalar[$tpe, $dims]
                        = macro SystemGenerator.method_impl[$tpe, $dims]
                    """
                  }
              }
            }

          }
          new $className {}
        """
      )
    }
  }

}

class body(tree: Any) extends StaticAnnotation

/**
 * A system is a list of accepted units.
 */
trait System[Units <: HList] {

  def measure[T <: UnitM[_]](value: Double)(implicit dimOf: DimensionsOf[Units, T])
    : Scalar[Units, dimOf.result] = new Scalar[Units, dimOf.result](value)

  /**
   * This conversion allows to use a double in prefix position of a Scalar operator, by converting it to a
   * dimensionless Scalar.
   */
  implicit class toScalarExtension(value : Double) {
    def scalar(implicit zeros : Zeros[Units]) : Scalar[Units, zeros.result]
    = new Scalar[Units, zeros.result](value)
  }


}

/**
 * This object is mearly used to keep the Scalar constructor protected. The measure method is
 * by the vampire methods that are generated by the fromHList macro, thus allowing the user
 * to write things like "3 meter / 2 second"
 */
object System {
  def measure[Units <: HList, T <: UnitM[_]](value: Double)(implicit dimOf: DimensionsOf[Units, T])
    : Scalar[Units, dimOf.result] = new Scalar[Units, dimOf.result](value)

  def scalar[Units <: HList, Dims <: HList](value : Double)
                                           (implicit lub1 : LUBConstraint[Units, UnitM[_]],
                                            lub2 : LUBConstraint[Dims, Integer],
                                            sameSize : SameSize[Units, Dims])
    : Scalar[Units, Dims] = new Scalar[Units, Dims](value)
}
